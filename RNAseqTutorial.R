# Testing RNAseq analysis
https://gist.github.com/jdblischak/11384914
# Install packages:----
source("https://bioconductor.org/biocLite.R")
biocLite("edgeR", dependencies = TRUE)
# a (update all)
# y (write personal library)

install.packages("ggplot2")

library(edgeR)
library(ggplot2)
##
# Download data:----
fname <- "http://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE49712&format=file&file=GSE49712_HTSeq.txt.gz"
download.file(fname, destfile = "GSE49712_HTSeq.txt.gz")

##
# Load data:----
data_raw <- read.table("GSE49712_HTSeq.txt.gz", header = TRUE)

##
# Quality control:----
class(data_raw)
dim(data_raw)
# 21716 genes, 10 samples
head(data_raw)
tail(data_raw)


# Data includes two different groups for comparison.
# Group A is five technical replicates of an equal mixture of RNA from ten different human cell lines.
# Group B is five technical replicates of pooled RNA from several regions of the brain.
# [a]: http://www.chem.agilent.com/Library/usermanuals/Public/740000.pdf
# [b]: http://www.lifetechnologies.com/order/catalog/product/AM6050

# Unlike the WGS data we saw before which generated aligned reads and variant calls,
# RNAseq generates count data where the number of reads aligned to a gene is counted and interpreted as expression level.
# Differential expression analysis allows inference of whether genes have higher 
# or lower expression under different conditions, between sample comparisons, across time.
# There is usually some comparison in mind, but not always. 
# RNAseq can also be used to describe the profile of a tissue, cell, or organism.

# The last 5 lines have summary information that needs to be removed prior to testing.
data_clean <- data_raw[1:(nrow(data_raw) - 5),]
dim(data_clean)

# Remove unexpressed and low-expressed genes:
# One method is to choose a cutoff that is informed by the data
# Calculate the median log-2 counts per gene per millian mapped reads (cpm)

cpm_log <- cpm(data_clean, log = TRUE)
median_log2_cpm <- apply(cpm_log, 1, median)
hist(median_log2_cpm)
expr_cutoff <- -1
abline(v = expr_cutoff, col = "red", lwd = 3)
sum(median_log2_cpm > expr_cutoff)
# 16217 genes retained
data_clean <- data_clean[median_log2_cpm > expr_cutoff, ]

# Check that we've filtered our genes:
dim(data_clean)
# 16217 genes, 10 samples
cpm_log_clean <- cpm(data_clean, log = TRUE)
median_log2_cpm_clean <- apply(cpm_log_clean, 1, median)
hist(median_log2_cpm_clean)

# Generate a heatmap of the correlation matrix to examine relationships between the comparison groups
# In this case, Group A and Group B are very different groups of cell lines
# so we expect them to have different expression profiles--overall gene expression patterns
# In addition, because the 5 sample replicates are technical replicates (sequencing the same sample 5 times)
# the within-group variation in gene expression is expected to be very low
heatmap(cor(cpm_log_clean))

# It is also common practice to use principal components analysis to look at relationships between comparison groups.
pca <- prcomp(t(cpm_log_clean), scale. = TRUE ) # transposes the data frame, scales variables so that they have unit variance
summary(pca)
PCA_data <- as.data.frame(pca$x)
head(PCA_data)
PCA_data$group <- c(rep("A", 5), rep("B", 5))

ggplot(PCA_data, aes(PC1, PC2, color = group)) +
  geom_point() +
  theme_classic()



###

# Two group comparison:----
# Preparing the data for DE, we need to assign a grouping variable that identifies
# the parts of the count data that belong to Group A and B
# The group variable and the count data are used to generate a DGEList
# which is used by edgeR to store data from a DE experiment

head(data_clean) # We want only the first letter of the column name
group <- substr(colnames(data_clean), 1, 1) # start at 1st position, end with 1st position
group

y <- DGEList(counts = data_clean, group = group)
y
class(y)

# Normalize gene counts:
# Used the TMM method (trimmed means of m values).
# Read counts for moderately to lowly expressed genes can be strongly influenced by small fluctuations in the expression of highly expressed genes.
# Small differences in highly expressed genes can make it look like there are also lots of lowly expressed genes with differential expression.
# TMM removes very high and very low expressed genes as well as genes that are very different across samples.
# The total counts for the subset of genes are then scaled.
# Assumes that the majority of genes are not different between any two samples

y <- calcNormFactors(y)
y$samples


# Model variance of read counts per gene:
# Measurements of gene expression variance generated by RNAseq data are typically overdispersed (larger than the mean gene expression).
# For this reason a negative binomial distribution is used.
# edgeR treats the Poisson variance as simple sampling variance with the dispersion estimate as the biological coefficient of variation.
# Technical biases are also included in this estimate.
# edgeR then determines a common dispersion estimate.
# Then, models the mean-variance relationship using the dispersion information.
# Calculates a dispersion estimate per gene and shrinks it towards the trended dispersion.
# Gene-specific (tagwise) dispersion estimates are used in the DE test

y <- estimateDisp(y)


y <- estimateDisp(y)
sqrt(y$common.dispersion) # biological coefficient of variation
plotBCV(y)

# The biological coefficient of variation is lower than normally seen in human studies (~0.4) because the samples are technical replicates.

# edgeR tests for differential expression between two classes using a method similar in idea to the Fisher's Exact Test.

et <- exactTest(y)
results_edgeR <- topTags(et, n = nrow(data_clean), sort.by = "none")
head(results_edgeR$table)

write.csv(results_edgeR$table, "test.table.csv")

# How many genes are differentially expressed at an FDR of 10%?
head(results_edgeR$table$FDR < .1)
sum(results_edgeR$table$FDR < .1) # R assigns the value 1 to TRUE logical data, so it's possible to count the trues
plotSmear(et, de.tags = rownames(results_edgeR)[results_edgeR$table$FDR < .1])
abline(h = c(-2, 2), col = "blue")

# As expected from the description of the samples and the heatmap, there are many differentially expressed genes.
# The [MA plot][ma] above plots the log~2~ fold change on the y-axis versus the average log~2~ counts-per-million on the x-axis.
# The red dots are genes with an FDR less than 10%.
# The blue lines represent a four-fold change in expression.



## Adding covariates

# The previous example was a two group comparison, but if you have additional covariates, you'll need to use a generalized linear model (GLM) framework.
# Let's say we processed the samples in two batches and also recorded the [RIN scores][rin] to control for differences in RNA quality.

# rin varies 1 - 10 with 10 being pristine and 1 totally degraded


set.seed(123) # sets a starting number to generate random data, setting seed allows us to get the same random data

batch <- sample(c("one", "two"), 10, replace = TRUE)
rin <- sample(6:10, 10, replace = TRUE)

batch
rin


# We need to create a design matrix to describe the statistical model.


y <- DGEList(data_clean)
y <- calcNormFactors(y)

y
design <- model.matrix(~group + batch + rin)
design

# Important to know how your samples are being compared. in this case b is compared to group a and batch 2 is compared to batch 1
# if you have a positive log fold change, does this mean that your treatment increased gene expression?
# case versus control, then yes but if its comaring control to case, then no.


# And now we test.
# The argument `coef = 2` corresponds to testing the second column of the design matrix, which in this case is whether the sample is from group A or B.

y <- estimateDisp(y, design)
y
fit <- glmFit(y, design)
lrt <- glmLRT(fit, coef = 2)
topTags(lrt)


# Make some plots of individual genes:

head(cpm_log_clean)
class(cpm_log_clean)

# First need to transpose
cpm_t <- t(cpm_log_clean)
head(cpm_t[,1:5])
class(cpm_t)

# Next add the group identifier:
# Matices can hold only one data type, because we are mixing numbers and characters by adding a group column
# need to switch to a dataframe

cpm_df <- as.data.frame(cpm_t)
class(cpm_df)
head(cpm_df[,1:5])

group

cpm_df$Group <- group
head(cpm_df[,1:5]) # adds it to the end
dim(cpm_df)
head(cpm_df[,16370:16372])

# What genes would be good to look at:
topTags(lrt)


ggplot(cpm_df, aes(Group, C1QB)) +
  geom_boxplot() +
  theme_classic()

ggplot(cpm_df, aes(Group, HBB)) +
  geom_boxplot() +
  theme_classic()

ggplot(cpm_df, aes(Group, CARD9)) +
  geom_boxplot() +
  theme_classic()


ggplot(cpm_df, aes(Group, SENP8)) +
  geom_boxplot() +
  theme_classic()

SENP8


# One more heatmap:
top_genes <- as.data.frame(topTags(lrt))
class(top_genes)
top_gene_names <- rownames(top_genes)
head(cpm_log_clean)

cpm_topgenes <- cpm_log_clean[top_gene_names, ]
cpm_topgenes

heatmap(cpm_topgenes)
